# TODO

## Now (W toku)

  - [x] Słownik reguł `rules.type` + wymagane `params` (2026-02-01)
  - [x] Walidacja `rules.type` i wymaganych `params` w schemacie (2026-02-01)
  - [x] Jednostki/układ współrzędnych + time unit (2026-02-01)
  - [x] Doprecyzować definicję `selector` (entity_id/tag) i użycie w `center/target` (2026-02-01)
  - [x] Doprecyzować zakres kroku "Interactions/Collisions" vs "Constraints/Bounds" (2026-02-01)
  - [x] Kolejność ewaluacji systemów (2026-02-01)
  - [x] Model kolizji i interakcji (2026-02-01)
  - [x] Emitery / spawny w czasie (2026-02-01)
  - [x] Uściślić schemat `emitters` (typy pól + walidacja) (2026-02-01)
  - [x] Dodać przykład DSL z `emitters` (2026-02-01)
  - [x] Definicje metryk do termination (2026-02-01)
  - [x] Ujednolicić kontrakt `termination.condition` i `fsm.transitions.when` dla metryk (2026-02-01)
  - [x] Rozważyć pole `systems.constraints` dla bounds (clamp/bounce) (2026-02-01)
  - [x] Walidacja `systems.constraints` (type/padding/restitution) (2026-02-01)
  - [x] Doprecyzować znaczenie `emitters.limit` (globalnie vs per-emitter) (2026-02-01)
  - [x] Walidacja kontraktu `termination.condition`/`fsm.when` dla metryk w schemacie (2026-02-01)
  - [x] Walidacja operatorów `op` dla metryk (dozwolony zestaw) (2026-02-01)
  - [x] Walidacja `name` dla metryk (dozwolony zestaw) (2026-02-01)
  - [x] Walidacja zakresów `value` dla metryk (np. coverage/stability 0..1) (2026-02-01)
  - [x] Walidacja `window_s` i `sample_every_s` dla metryk (>= 0) (2026-02-01)
  - [x] Walidacja relacji `sample_every_s <= window_s` (gdy oba podane) (2026-02-01)
  - [x] Zdefiniować `entities.tags` i walidację selectorów `tag:` względem encji (2026-02-01)
  - [x] Ujednolicić `termination.condition.type` (np. tylko `metric` vs legacy types) (2026-02-01)
  - [x] Słownik dystrybucji `spawns/emitters.distribution.type` + wymagane `params` (2026-02-01)
  - [x] Słownik `systems.forces` (typy + params) + walidacja (2026-02-01)
  - [x] Uściślić `systems.interactions` (schema + walidacja `pairs` i rule) (2026-02-01)
  - [x] Doprecyzować `entities.size` (typy obiektów, zakresy, jednostki) (2026-02-01)
  - [x] Doprecyzować `entities.render` (dozwolone pola i typy) (2026-02-01)
  - [x] Ujednolicić przykłady DSL pod `termination.condition.type: metric` (2026-02-01)
  - [x] Walidacja `distribution.params` per typ (np. grid: cols/rows; orbit: radius) (2026-02-01)
  - [x] Walidacja `entities.size` (min/max/distribution) w schemacie (2026-02-01)
  - [x] Walidacja `entities.render` (stroke/opacity) w schemacie (2026-02-01)
  - [x] Walidacja `systems.interactions.rule.params` zgodnie ze słownikiem reguł (2026-02-01)
  - [x] Walidacja kolorów `entities.color`/`render.stroke.color` względem `scene.palette` (2026-02-01)
  - [x] Walidacja opcjonalnych `distribution.params` (np. orbit.speed, random.padding typ/zakres) (2026-02-01)
  - [x] Walidacja `scene.background` względem `scene.palette` (2026-02-01)
  - [x] Walidacja formatu kolorów w `scene.palette` (np. hex `#RRGGBB`) (2026-02-01)
  - [x] Walidacja `scene.canvas` (wymiary/fps/duration > 0) (2026-02-01)
  - [x] Walidacja `output` (format/codec/resolution/bitrate) + zgodność z `scene.canvas` (2026-02-01)
  - [x] Walidacja enumów: `entities.shape` i `distribution.type` (2026-02-01)
  - [x] Walidacja unikalności `entities.id`, `rules.id`, `emitters.id` (2026-02-01)
  - [x] Walidacja `entities.tags` (format, brak pustych, unikalność) (2026-02-01)

## Next (Kolejne)
- [ ] Renderer: implementacja reguł (branch: feat/renderer-rules)
  - [ ] Reguły: move / orbit / attract / repel
  - [ ] Reguły: split / merge / decay
  - [ ] Reguły: memory + ślady
  - [ ] FSM w rendererze
  - [ ] Zgodność kolejności ewaluacji z DSL (forces/interactions/constraints)
  - [ ] Obsługa selectorów `tag:`/`all` i wyboru „najbliższego” w center/target
  - [ ] Emitery: spawny w czasie zgodne z DSL v1.1
  - [ ] Constraints/bounds: clamp/bounce/wrap zgodnie z DSL v1.1
  - [ ] Forces: gravity/noise zgodnie z DSL v1.1
  - [ ] Zgodność reguł z DSL v1.1 (po rozszerzeniu)
- [ ] Baza danych + migracje (branch: feat/db-schema)
  - [ ] Szkielet DB (Postgres + Alembic)
  - [ ] Podstawowy model danych: animacja, render, QC, audit
  - [ ] Migracje startowe
- [ ] Minimalny worker pipeline (branch: feat/pipeline-mvp)
  - [ ] RQ + Redis: generacja -> render
  - [ ] Logowanie statusów jobów

## Done (Zrobione)
- [x] DSL v1.1 rozszerzenia (branch: feat/dsl-v1-1) (2026-02-01)
- [x] Utworzenie TODO.md (branch: chore/todo) (2026-01-30)
  - [x] Zdefiniować strukturę zadań i zasady utrzymania TODO (2026-01-30)
- [x] Dev environment bootstrap (branch: chore/dev-setup) (2026-01-31)
  - [x] Zweryfikować i uzupełnić środowisko dev na macOS (Brewfile + versions.env)
  - [x] Przygotować skrypt bootstrapu macOS (scripts/setup-macos.sh) i wpisać do Makefile (2026-01-30)
  - [x] Wymusić użycie /opt/homebrew w bootstrapie i zweryfikować ścieżkę brew (2026-01-30)
  - [x] Instalować tylko brakujące brew/cask (pomijać istniejący Docker.app) (2026-01-30)
  - [x] Trwale pominąć instalację Docker cask w bootstrapie (2026-01-30)
  - [x] Przenieść wersje Python/Node do mise i dodać .mise.toml (2026-01-31)
  - [x] Zaufać konfiguracji mise (mise trust) (2026-01-31)
  - [x] Naprawić uprawnienia Homebrew i cache (np. /opt/homebrew/Cellar, /opt/homebrew/var/homebrew/locks, ~/Library/Caches/Homebrew) (2026-01-31)
  - [x] Sprawdzić ACL/flags blokujące zapis (np. /opt/homebrew/var/homebrew/locks, ~/Library/Caches/Homebrew) (2026-01-31)
  - [x] Ustawić Node 24 jako aktywny przez mise (2026-01-31)
  - [x] Ustalić, że `make verify` traktuje skia-python i usługi z compose jako opcjonalne (2026-01-31)
  - [x] Usunąć tap `homebrew/bundle` z Brewfile (tap zdeprecjonowany) (2026-01-30)
  - [x] Uruchomić bootstrap lokalnie i potwierdzić działanie (make setup-macos, make verify) (2026-01-31)
  - [x] Spisać minimalne kroki uruchomienia lokalnego (README: 5-min quickstart) (2026-01-31)
- [x] DSL v1 + walidacja (branch: feat/dsl-v1) (2026-02-01)
  - [x] Opisać DSL v1: struktura pliku, pola wymagane, opcjonalne, wersjonowanie (2026-01-31)
  - [x] Zdefiniować minimalny kontrakt FSM (stany, przejścia, parametry, wejścia/wyjścia) (2026-01-31)
  - [x] Przygotować 2 przykładowe pliki DSL v1 (happy path + edge case) (2026-01-31)
  - [x] Wybrać format wejścia (JSON albo YAML) i uzasadnić w krótkiej notce (2026-01-31)
  - [x] Zaimplementować schemat DSL (pydantic/jsonschema) + walidator wejścia (2026-01-31)
  - [x] Dodać testy walidacji DSL (min. valid/invalid cases) (2026-01-31)
  - [x] Dodać zależności Python (pyproject + lock) dla DSL/testów (pydantic, pyyaml, pytest) (2026-02-01)
  - [x] Usunąć warningi Pydantic v2 (Config -> ConfigDict) (2026-02-01)
- [x] Minimalny renderer MVP (branch: feat/renderer-mvp) (2026-02-01)
  - [x] Renderer Python + Cairo z deterministycznym seedingiem (2026-02-01)
  - [x] Metadane renderu: seed, dsl_version, design_system_version, parametry symulacji (2026-02-01)
  - [x] Ustalić spójną wersję FFmpeg w PATH (obecnie używany 7.1.1 vs pinned 8.0.1) (2026-02-01)
  - [x] Ostrzeganie o nieobsługiwanych regułach/FSM w rendererze (2026-02-01)
- [x] CLI do renderu (branch: feat/render-cli) (2026-02-01)
  - [x] Wejście: DSL + seed, wyjście: wideo + metadane (2026-02-01)
  - [x] Walidacja wejścia i czytelne błędy (2026-02-01)
- [x] Deterministyczność renderu (branch: test/renderer-golden) (2026-02-01)
  - [x] Golden tests (min. 2 przypadki) (2026-02-01)
  - [x] Tolerancje porównań i dokumentacja (2026-02-01)

## Zasady
- Jeden właściciel taska i jeden cel; task ma kończyć się działającym artefaktem lub testem
- Przenoś zadania między sekcjami tylko przy zmianie statusu (Now -> Done, Next -> Now)
- Dopisuj datę przy ukończonych zadaniach w sekcji Done, np. "(2026-01-30)"
- Zadania główne odpowiadają branchom (jedno zadanie = jeden branch), podzadania realizujemy w ramach tego brancha
- Preferowane prefiksy branchy: `feat/`, `chore/`, `test/`, `docs/`, `fix/`
- Zadanie główne powinno być zamykalne w 1–3 dni robocze; jeśli rośnie, podziel je na dwa branche
- TODO utrzymujemy jako 2 poziomy: tylko zadania główne + podzadania (bez kolejnych poziomów)
- Liczba podzadań jest elastyczna (1–7); przy 1 podzadaniu upewnij się, że branch nadal ma sens
- Przykład małego brancha: dokument/konwencja w jednym pliku (np. TODO, README, RFC-lite)

## Notatki / decyzje
- Docker Desktop instalujemy manualnie (bootstrap pomija cask docker).
- Python/Node instalujemy i pinujemy przez mise (`.mise.toml`).
- `make verify` traktuje skia-python i usługi z compose jako opcjonalne do czasu uruchomienia renderera i infra.
