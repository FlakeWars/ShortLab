# TODO

## Now (W toku)
- [ ] LLM task profiles (branch: feat/llm-task-profiles)
  - [x] `idea_generate` -> profil kreatywny
  - [x] `idea_verify_capability` -> profil analityczny/skrupulatny
  - [x] `idea_compile_dsl` + `dsl_repair` -> profil structured-output/precyzyjny
  - [x] Konfiguracja domyślnych modeli per profil bez zmian po stronie klientów
  - [ ] Dodać test integracyjny mapowania profili na realnych providerach (OpenRouter/Groq/LiteLLM) poza mockami
- [ ] UI: układ i nawigacja (branch: feat/ui-layout)
  - [x] Przeprojektowanie z "długiej strony" na app-shell z nawigacją zakładkową (MVP)
  - [x] Wdrożenie kolejności: `Home/Control Tower` -> `Plan/Calendar` -> `Flow` -> `Repositories` -> `Settings`
  - [x] Dodać klarowne CTA-linki między widokami (bez ręcznego przełączania zakładki) — MVP
  - [ ] UX review paneli (czytelność, hierarchia, skrócenie tekstów)
  - [x] Utrwalać aktywną zakładkę w URL/query-param, żeby odświeżenie nie resetowało kontekstu
  - [ ] Dodać mapę przyjaznych slugów + tytułów (np. `view=flow` -> "Flow operatora")
  - [x] Flow board: karty etapów z licznikami + CTA do odpowiednich sekcji
  - [x] Flow tab zawiera mini‑listę Animations (bez skoku do Repositories)
  - [ ] Wydzielić pełną listę animacji do Repositories i dopisać jasno w UI różnicę "mini vs full"
- [ ] Pipeline: stabilizacja dev (branch: fix/dev-pipeline-stability)
  - [x] `run-dev` ładuje `.env` i `.env.local`
  - [x] Worker bez forka (SimpleWorker) w dev
  - [x] Cleanup jobów w `run-dev` nie ubija po 1 min (konfigurowalne `CLEANUP_OLDER_MIN`)
  - [x] Wymusić fork-safety dla workera (OBJC var + dispose engine)
  - [ ] Dodać krótką notkę w README o `CLEANUP_OLDER_MIN` i SimpleWorker w dev

## Next (Kolejne)
- [ ] Similarity scaling (branch: feat/similarity-scaling)
  - [ ] Wdrozyć ANN index (FAISS/HNSW) dla embeddingów idei
  - [ ] Async podobienstwo: obliczenia w tle + status `similarity_status` aktualizowany po fakcie
  - [ ] Integracja z generatorem: fallback do "unknown" gdy ANN niegotowy
  - [ ] Monitoring kosztu O(N) do czasu wdrozenia ANN (metryka czasu per batch)
- [ ] UI: doprecyzować komunikację capability vs idea (branch: feat/ui-capability-copy)
  - [ ] Spójne nazewnictwo kandydatów vs idei w panelach Flow/DSL Capability
  - [ ] Podpowiedzi w UI: kiedy powstaje Idea i dlaczego Idea Gate filtruje tylko feasible
- [ ] UI: LLM usage panel v1.1 (branch: feat/ui-llm-usage)
  - [ ] Dodać drill-down per request/run (powiązanie z konkretnym `idea_id` / jobem)
  - [ ] Dodać komunikat, że koszt estymowany = 0 gdy brak `LLM_PRICE_DEFAULT_*`
  - [ ] Dodać prosty alert budżetowy (np. >80% `LLM_DAILY_BUDGET_USD`)
- [ ] Process debt po zmianach dev-runner (branch: chore/process-discipline)
  - [ ] Udokumentować odstępstwo: commit wykonany bezpośrednio na `main` (bez branch workflow)
  - [ ] Dodać checklistę „pre-commit AGENTS.md” i stosować przed każdym commitem
  - [ ] Wymusić rytuał po merge: krótka analiza wpływu + aktualizacja TODO (Now/Next/Done)
- [ ] VLM: analiza wygenerowanej animacji (branch: feat/vlm-animation-analysis)
  - [ ] Sprawdzić modele multimodalne (wideo/klatki) i wybrać dostępne przez mediator
  - [ ] MVP: analiza klatek kluczowych (zgodność z ideą, dynamika, czytelność)
  - [ ] Raport `animation_analyze` do QC (score + uzasadnienie + rekomendacje)
  - [ ] Integracja z pipeline: opcjonalny krok po renderze przed decyzją QC
- [ ] UI: Idea Gate (branch: feat/ui-idea-gate)
  - [ ] Wyświetla kilka propozycji + wybór (radio/CTA)
  - [ ] Rozszerzony opis propozycji (what_to_expect/preview)
  - [ ] Akcja wyboru propozycji zapisywana w DB
- [ ] UI: auto‑refresh i ergonomia (branch: feat/ui-refresh)
  - [ ] Automatyczne odświeżanie listy animacji/jobów (polling)
  - [ ] Wyraźny przycisk „Odśwież” obok filtrów
- [ ] UI: panel stanu systemu jako pierwszy ekran (branch: feat/ui-system-status)
  - [x] Sekcja health serwisów (API, worker, Redis, Postgres, storage) z lampkami green/red
  - [x] Sekcja liczników repozytoriów (idee, dsl_gap, animacje, rendery, artefakty; docelowo SFX/music)
  - [x] Rozbicie liczników per status (np. idee: unverified/ready_for_gate/blocked)
  - [ ] Linki CTA z panelu statusu do widoków szczegółowych repozytoriów
  - [ ] Definicja SLO panelu (czas odświeżania, timeouty, fallback przy częściowej niedostępności)
  - [x] UX: panel statusu jako domyślny pierwszy panel po wejściu do UI
  - [ ] Lepsza obsługa niezgodności wersji API/UI (gdy działa stary backend bez `/system/status`, pokazać czytelny komunikat i hint restartu)
  - [x] Opisy IDEA_CANDIDATES vs IDEAS + kolejność zgodna z flow
- [ ] API: agregaty dla panelu stanu systemu (branch: feat/api-system-status)
  - [x] Endpoint zbiorczy health + repo counters (jedno źródło dla UI status)
  - [x] Standaryzacja kontraktu: `service_status[]`, `repo_counts`, `updated_at`, `partial_failures[]`
  - [x] Liczniki dla repozytoriów istniejących + placeholdery dla przyszłych (SFX/music)
- [ ] UI: ograniczyć warningi hooków (`react-hooks/exhaustive-deps`) w `frontend/src/App.tsx` (branch: fix/ui-hook-warnings)
  - [ ] Ustabilizować funkcje fetch przez `useCallback` albo celowy disable z uzasadnieniem
  - [ ] Lint bez narastających warningów
- [ ] Ryzyko: zbyt ciężkie zapytania liczników (branch: fix/status-counters-performance)
  - [ ] Dodać limity/cache (krótki TTL) dla endpointu agregatów
  - [ ] Monitoring czasu odpowiedzi endpointu statusowego
- [ ] UX IA v2: Control Tower / Plan / Flow (branch: feat/ui-ia-v2)
  - [ ] `Home / Control Tower`: health + KPI + "co teraz" + alerty z CTA
  - [ ] `Plan / Calendar`: tydzień publikacji, backlog gotowych animacji, statusy `planned/ready/blocked/published`
  - [ ] `Flow`: stepper operatora `Idea Gate -> Compile DSL -> Render -> QC -> Publish`
  - [ ] W `Flow` pokazywać tylko aktywną ścieżkę i następny krok; automatyzacje w tle
  - [ ] `Repositories`: osobny obszar analityczno-administracyjny (bez mieszania z flow)
  - [ ] Definicja stanów pustych/błędów dla każdego widoku (w tym niezgodność API/UI)
- [ ] Procedura obsługi `dsl_gap` (branch: feat/dsl-gap-procedure)
  - [ ] Zdefiniować workflow: triage -> decyzja (accept/reject) -> implementacja -> re-verify idei
  - [ ] Dodać w UI alert/CTA dla operatora gdy backlog gapów blokuje flow
  - [ ] Dodać kryteria "done" dla implementacji gapa (testy + przykładowe idee odblokowane)
- [ ] UI: QC (branch: feat/ui-qc)
  - [ ] Panel QC w UI + akcja accept/reject/regenerate
- [ ] UI: publikacja (branch: feat/ui-publish)
  - [ ] Panel publikacji + zapis `publish_record`
  - [ ] Widok statusu publikacji i metryk
- [ ] Pipeline: jobs wiszą w queued (branch: fix/queue-stuck)
  - [ ] Diagnostyka: worker/redis/queue
  - [x] UI: sygnalizacja „worker offline”
  - [ ] Dodać watchdog stale queued (timeout + auto-requeue lub fail-safe)
- [ ] Pipeline: worker crash przy niepoprawnym UUID (branch: fix/worker-failure-callback)
  - [x] Zabezpieczyć rq_on_failure/_coerce_uuid przed ValueError (nie crashować workera)
  - [ ] Dodać test lub smoke case dla błędnego job_id
- [ ] Pipeline: UUID w JSON payload (branch: fix/uuid-json)
  - [ ] Zamieniać UUID -> str przed zapisem JSON (psycopg JSON dump)
  - [ ] Dodać test dla payload z UUID
- [ ] Idea → DSL mapping (branch: feat/idea-to-dsl)
  - [ ] Mapowanie pola idei na parametry DSL (seed, liczba bytów, tempo/duration)
  - [ ] Warianty reguł/parametrów w oparciu o preview/summary
  - [ ] Wymusić widoczne różnice (paleta, tło, kształty, promień orbity)
  - [ ] Test: różne idee → różne DSL
  - [ ] Dodać metrykę „delta DSL vs template” i minimalny próg różnorodności
  - [ ] Walidacja: brak użycia template w promptach kompilatora (test regresji)
- [ ] Audio: SFX repo + kolizje (branch: feat/audio-sfx)
  - [ ] Repozytorium efektów (SFX) + metadane (tagi/rodzaj/poziom głośności)
  - [ ] Mapowanie zdarzeń w rendererze -> SFX (kolizje, spawn, merge/split)
  - [ ] Mixer: złożenie SFX z wideo (FFmpeg)
  - [ ] Konfiguracja w DSL/metadata (włącz/wyłącz, głośność)
- [ ] Audio: muzyka tła (branch: feat/audio-music)
  - [ ] Repozytorium podkładów (licencja, długość, BPM, nastrój)
  - [ ] Wybór podkładu per animacja + miks z SFX
  - [ ] Prosta reguła wyboru (tagi/nastrój/długość)
- [ ] Audio: kontrakt danych (branch: feat/audio-events)
  - [ ] Zdarzenia audio emitowane z renderera (timestamp + typ)
  - [ ] Format pliku events.json dla miksowania
- [ ] Feedback Analytics (branch: feat/feedback-analytics)
  - [ ] Model danych: parametry idei + metryki wynikowe (views, retention, CTR, itp.)
  - [ ] Eksperymenty/atrybucja: korelacje między cechami idei a wynikami
  - [ ] Raport/insight: rekomendacje dla generatora idei
  - [ ] Interfejs (UI/API) do przeglądu insightów
- [ ] Platform Registry (branch: feat/platform-registry)
  - [ ] Ujednolicony interfejs publikacji (publish/status/metrics)
  - [ ] Rejestr platform + pluginy (YouTube/TikTok jako pierwsze)
  - [ ] Konfiguracja per platforma (klucze, limity, pola opcjonalne)
- [ ] Experiment Planner (branch: feat/experiment-planner)
  - [ ] Planowanie serii animacji z kontrolą zmiennych (A/B, serie, warianty)
  - [ ] Metadane eksperymentu powiązane z animacjami
  - [ ] Raport porównawczy wyników (prosty MVP)
- [ ] Style Pack Manager (branch: feat/style-pack)
  - [ ] Repo stylów (palety, tła, typografia, grubości linii)
  - [ ] Przypisanie style_pack do animacji/renderu
  - [ ] UI: wybór stylu dla serii/eksperymentu
- [ ] Auto-QC (branch: feat/auto-qc)
  - [ ] Heurystyki jakości (dynamika, kontrast, „pusty kadr”)
  - [ ] Flagi ostrzegawcze w UI + sugerowane działania
- [ ] Trend Scanner (branch: feat/trend-scanner)
  - [ ] Ręczne tagi trendów/tematów + ważność
  - [ ] Powiązanie trendów z pomysłami/animacjami
- [ ] Retention Proxy (branch: feat/retention-proxy)
  - [ ] Heurystyki „nudnych” odcinków (brak zdarzeń > X s)
  - [ ] Flagi jakości przed publikacją
- [ ] Seed Explorer (branch: feat/seed-explorer)
  - [ ] Mini‑render K wariantów seed
  - [ ] Wybór najlepszego na podstawie heurystyk
- [ ] Content Calendar (branch: feat/content-calendar)
  - [ ] Kalendarz publikacji + tematy/styl dnia
  - [ ] Generator dobiera pomysł pod dzień
- [ ] Asset Policy / Licenses (branch: feat/asset-policy)
  - [ ] Repo assetów z licencją i ograniczeniami użycia
  - [ ] Blokady użycia niezgodnych assetów
- [ ] Dev: spójny REDIS_URL dla run-dev/job-status (branch: chore/dev-redis)
  - [ ] Ujednolicić DB index (0/1) i opisać w README/Makefile
  - [x] Job-status/cleanup używa tej samej bazy co run-dev

## Done (Zrobione)
- [x] UI: przełącznik języka + motyw jasny/ciemny (2026-02-06)
  - [x] UI: language selector (PL/EN) zapisany w localStorage i używany w generatorze/weryfikatorze
  - [x] UI: theme toggle (light/dark) z `.dark` na `<html>`
- [x] Prompty LLM: parametr języka odpowiedzi (2026-02-06)
  - [x] Generator idei: wymusza język odpowiedzi
  - [x] Weryfikator DSL: gap reason/impact w języku użytkownika (feature w snake_case)
  - [x] Kompilator: język pól „human-readable” zgodny z ideą
- [x] UI: pokazuj zrodlo weryfikacji (LLM/fallback) (branch: feat/ui-verifier-indicator) (2026-02-05)
  - [x] Panel DSL Capability: provider/model + tryb weryfikacji
- [x] Post-merge analysis (2026-02-05)
  - [x] UI z indykatorem weryfikatora LLM/fallback
- [x] LLM Capability Verifier (branch: feat/llm-capability-verifier) (2026-02-05)
  - [x] Wspolny prompt/DSL spec dla walidatora i kompilatora
  - [x] Walidacja LLM dla idei/kandydatow + fallback heurystyczny
  - [x] UI: sygnalizowac czy wynik z LLM czy fallback
- [x] Post-merge analysis (2026-02-05)
  - [x] Walidator oparty o LLM + fallback heurystyczny
- [x] Fix: Idea Gate sample + polish UI (branch: fix/idea-gate-sample) (2026-02-05)
  - [x] `/idea-repo/sample` zwraca kompletne pola kandydatów (bez `{}`)
  - [x] Flow panel przed Generator w zakładce Flow
  - [x] Repo kandydatów: podgląd treści (summary/what_to_expect/preview)
  - [x] Idea Gate: komunikat gdy brak propozycji
- [x] Post-merge analysis (2026-02-05)
  - [x] Naprawiony sampling + UX w Idea Gate
- [x] UI: Idea Generator (branch: feat/ui-idea-generator) (2026-02-05)
  - [x] API: POST `/idea-candidates/generate` (LLM/text/file)
  - [x] UI: panel generowania z trybami LLM/text/file
  - [x] Repositories: lista kandydatów + filtry status/capability/similarity
  - [x] Flow: pierwszy krok uruchamiany z UI
- [x] Post-merge analysis (2026-02-05)
  - [x] Dopisany endpoint i UI dla generowania kandydatów
- [x] UI: panel Idea Generator w Flow (branch: feat/ui-flow-idea-generator) (2026-02-05)
  - [x] Pierwszy krok flow z licznikami capability i statusu kandydatów
  - [x] System status: IDEA CANDIDATES z capability_status + status w stałej kolejności
  - [x] Backlog: Similarity scaling (ANN + async) dopisany do TODO
- [x] Post-merge analysis (2026-02-05)
  - [x] UI Flow zaktualizowany o pierwszy etap i opis similarity
- [x] DSL capability na IdeaCandidate (branch: feat/idea-candidate-capability) (2026-02-05)
  - [x] Model DB: `capability_status` na `idea_candidate` + tabela `idea_candidate_gap_link`
  - [x] API: weryfikacja kandydatów + sampling tylko feasible + decide tworzy `idea` jako `ready_for_gate`
  - [x] UI: liczniki wg capability + lista zablokowanych kandydatów
  - [x] Docs sync: PRD/tech-stack/README (capability na kandydatach + status kompilatora + komendy verify)
  - [x] Dodany opis flow w `.ai/flow.md`
- [x] Post-merge analysis (2026-02-05)
  - [x] Dokumentacja zaktualizowana: `.ai/prd.md`, `.ai/tech-stack.md`, `README.md`
- [x] UI: panel LLM usage (branch: feat/ui-llm-usage) (2026-02-04)
  - [x] Widok tokenów/kosztu per task/provider/model na podstawie `/llm/metrics`
  - [x] Kafelki sumaryczne (calls, tokens, est. cost, daily budget)
  - [x] Odświeżanie ręczne + polling co 30s
- [x] UX: stabilizacja run-dev/stop-dev (branch: fix/run-dev-stability) (2026-02-04)
  - [x] `make run-dev` bez błędu, gdy już działa (czytelny komunikat + exit 0)
  - [x] `make stop-dev` ubija procesy i zwalnia porty (bez ręcznego `lsof|kill`)
  - [x] `make run-dev` automatycznie sprząta zaległy PID file
- [x] LLM Idea->DSL Compiler (branch: feat/llm-dsl-compiler-impl) (2026-02-04)
  - [x] Kompilacja tylko dla idei `feasible`/`ready_for_gate`
  - [x] Pętla lokalna: `generate -> validate -> repair -> retry`
  - [x] Kompilator buduje DSL od zera (prompt v2, bez template)
  - [x] Mediator naprawia odpowiedzi nie-JSON (extract + repair call)
  - [x] Fallback w weryfikatorze nie oznacza `feasible` bez gapów (zostaje `unverified`)
  - [x] Twarde walidacje syntax + semantics + raport błędów
  - [x] Tryb awaryjny fallback (jawny, nie maskujący błędu semantycznego)
  - [x] Testy E2E: 5 idei referencyjnych + różne wyniki DSL
  - [x] Dodać endpoint/CLI do wymuszenia kompilacji Idea->DSL (obecnie ścieżka aktywowana w pipeline przez feature-flag)
  - [x] Dodać test API dla `/ideas/{idea_id}/compile-dsl` (success + idea_not_feasible)
  - [x] Dodać pełny test pipeline (generate_dsl_job -> render) dla 5 idei z aktywnym kompilatorem
    - [x] Dodany test `tests/test_idea_compiler_pipeline_e2e.py` (5 idei, aktywny kompilator, różne hash'e DSL)
    - [x] Usunąć warunek skip przez ujednolicenie schematu testowej bazy (target `make test-idea-compiler-pipeline-e2e` resetuje i migruje DB)
- [x] Warning debt: `datetime.utcnow()` deprecations (branch: fix/datetime-utcnow) (2026-02-04)
  - [x] Zamienić domyślne timestampy modeli i logiki na timezone-aware `datetime.now(datetime.UTC)`
  - [x] Uruchomić testy bez deprecation warningów SQLAlchemy/Python
- [x] Testy dla persystencji DB mediatora LLM (branch: test/llm-mediator-db-workflow) (2026-02-04)
  - [x] Testy jednostkowe: serializacja/liczniki i odczyt snapshotu `/llm/metrics`
  - [x] Test round-trip backendu `db` na fake session (bez prawdziwego Postgresa)
  - [x] Test integracyjny: zapis/odczyt tabel `llm_mediator_*` + fallback plikowy przy awarii DB
  - [x] Smoke dla `make llm-mediator-retention` z kontrolą cutoffów
  - [x] Dodać pakiet testów do lokalnego workflow z uruchomionym Postgres (`make test-llm-mediator-db`)
- [x] Process: sync dokumentacji po każdym merge (branch: chore/docs-sync-post-merge) (2026-02-04)
  - [x] Dodać checklistę "PRD/Tech-Stack/README sync" do rytuału post-merge
  - [x] Przy każdym merge wpisywać w TODO, które sekcje dokumentacji zmieniono i dlaczego
  - [x] Rozdzielać w dokumentach: "stan aktualny" vs "plan/docelowo", by nie mieszać implementacji z roadmapą
- [x] LLM Mediator (branch: feat/llm-mediator) (2026-02-04)
  - [x] Zdefiniować jeden kontrakt klienta: `task_type + payload` (klient nie zna dostawcy ani modelu)
  - [x] Dodać routing po `task_type` -> `provider + model` z konfiguracji mediatora
  - [x] Obsłużyć adaptery: OpenRouter, Groq, LiteLLM (min. 1 aktywny + fallback)
  - [x] Retry/timeout/circuit-breaker + standaryzacja błędów niezależnie od dostawcy
  - [x] Telemetria: koszt, latencja, success rate per `task_type` i per provider/model
  - [x] Polityka bezpieczeństwa: redakcja danych w logach + limity tokenów i kosztów
  - [x] Persist/eksport metryk mediatora (plik stanu + endpoint `/llm/metrics`)
  - [x] Twarde limity budżetu dziennego z persystencją
- [x] LLM Mediator - trwała persystencja DB (branch: feat/llm-mediator-db-persistence) (2026-02-04)
  - [x] Przenieść metryki i budżet z JSON state file do DB
  - [x] Dodać migracje + retention polityki dla metryk mediatora
  - [x] Zachować kompatybilność z obecnym endpointem `/llm/metrics`
- [x] Idea Gate: filtrowanie tylko idei wykonalnych (branch: feat/idea-gate-feasible-only) (2026-02-04)
  - [x] Gate pobiera wyłącznie idee o statusie `ready_for_gate`
  - [x] Komunikaty UI dla idei zablokowanych przez `dsl_gaps`
- [x] DSL Capability Verifier (branch: feat/dsl-capability-verifier) (2026-02-04)
  - [x] Model danych: `dsl_gap` + `idea_gap_link` + statusy idei (`unverified/feasible/blocked_by_gaps/ready_for_gate`)
  - [x] Dedup gapów: wykrywanie istniejących `dsl_gap` i linkowanie bez duplikatów
  - [x] Wynik weryfikacji: `TAK/NIE` + raport + lista nowych/istniejących gapów
  - [x] Re-verification po wdrożeniu gapa (`implemented`) i odblokowanie idei
  - [x] API/UI: podgląd statusu wykonalności idei i listy gapów
- [x] LLM DSL Compiler (module planning) (branch: feat/llm-dsl-compiler) (2026-02-04)
  - [x] Discovery: cele, zakres, ryzyka, granice odpowiedzialności
  - [x] Kontrakt wej/wyj + wersjonowanie (Idea → DSL + metadata)
  - [x] Spec DSL v1 (minimalny, jednoznaczny, z przykładami)
  - [x] Plan walidacji: syntaktyczna + semantyczna + jakościowa
  - [x] Strategie awaryjne: repair → retry → fallback
  - [x] Telemetria: log błędów, dsl_gaps, koszt/latencja
  - [x] Kryteria akceptacji E2E
  - [x] Prototyp: LLM prompt + 3–5 testowych idei
  - [x] Rewizja architektury: rozdział na `DSL Capability Verifier` i `Idea->DSL Compiler`
  - [x] Uszczegółowienie kontraktów I/O, źródeł zasobów i polityk deduplikacji gapów
- [x] Idea Repository (branch: feat/idea-repo) (2026-02-03)
  - [x] Doprecyzować kontrakt (stany: new/later/rejected/picked) i losowanie N
  - [x] Zmiany DB: status/decyzje + audit (rejected -> delete)
  - [x] Losowanie: status in (new,later), natychmiastowy powrót "later"
  - [x] Pipeline zatrzymuje się bez wyboru (brak auto-selekcji)
  - [x] API/UI: losowanie + klasyfikacja wszystkich N (picked/later/rejected)
- [x] Stabilizacja pycairo na ARM64 (branch: fix/pycairo-arm) (2026-02-03)
  - [x] Dodać instrukcję budowy pycairo z źródeł (ENV flags) i target Makefile
  - [x] Zweryfikować `make pycairo-arm` na czystym setupie (Xcode CLT + Brew cairo)
  - [x] Dopisać meson do Brewfile i instrukcji (wymagany przez pycairo build)
- [x] Re-lock zależności dla Python 3.12 (branch: chore/py312-lock) (2026-02-03)
  - [x] `make deps-py-lock` + `make deps-py-uv` bez błędów na cp312
- [x] Dev runner: make run-dev / stop-dev (branch: chore/run-dev) (2026-02-02)
  - [x] Skrypt uruchamiania API+UI+worker z jednymi portami i REDIS db=1
  - [x] Skrypt zatrzymywania procesow
- [x] Ujednolicenie Pythona do 3.12 w całym repo (branch: chore/python-3-12) (2026-02-02)
  - [x] versions.env + .mise.toml + pyproject + uv.lock
  - [x] Makefile + run-dev bez osobnego venv
  - [x] Usunięcie lokalnego .venv312
- [x] Settings runtime: API endpoint do podgladu configu (branch: feat/settings-api) (2026-02-02)
  - [x] UI pobiera ustawienia z API zamiast VITE_*
- [x] Security: wymusic token operatora w prod (branch: fix/ops-guard) (2026-02-02)
  - [x] Blokada uruchomienia /ops/* bez OPERATOR_TOKEN w trybie produkcyjnym
- [x] Stabilizacja operacji i dokumentacji (branch: chore/ops-docs) (2026-02-02)
  - [x] Dokumentacja: OPERATOR_TOKEN + przyklady curl dla /ops/*
  - [x] Smoke testy: /ops/enqueue, /ops/rerun, /ops/cleanup-jobs z tokenem
  - [x] Dokumentacja: uzycie generatora OpenAI (source=openai, env vars)
- [x] API/UI: polityka serwowania artefaktow (branch: fix/api-artifacts) (2026-02-02)
  - [x] Ustalic dozwolony katalog bazowy (obecnie tylko `out/`) i opisac w docs
- [x] Generator pomyslow: integracja LLM provider (branch: feat/idea-generator-llm) (2026-02-02)
- [x] Panel UI: integracja operacyjna (branch: feat/ui-ops) (2026-02-02)
  - [x] Akcje operacyjne: enqueue, rerun, cleanup jobow
  - [x] Minimalne auth/guard (operator-only)
- [x] Panel UI: frontend (MVP) (branch: feat/ui-frontend) (2026-02-02)
  - [x] Bootstrap frontendu (Vite + React + TS) + piny wersji
  - [x] Dashboard stanu pipeline (queued/running/failed/succeeded) + ostatnie joby
  - [x] Tailwind + shadcn/ui: konfiguracja i spójny design dashboardu
  - [x] Lista animacji z filtrem po statusie + podglad metadanych
  - [x] Podglad renderow (wideo + metadane) + status QC
  - [x] Sekcja Idea Gate: propozycje + wybor + podobienstwo
  - [x] Historia zdarzen (audit log) + filtr po typie
  - [x] Ustawienia (timeouts, .env flags) tylko do podgladu w MVP
- [x] Panel UI: backend API (MVP) (branch: feat/ui-api) (2026-02-02)
  - [x] Endpointy statusu pipeline (summary + joby)
  - [x] Lista animacji + metadane + status QC
  - [x] Audit log (lista + filtry)
  - [x] Idea Gate: lista propozycji + status podobienstwa
  - [x] Naprawa API: sesje DB w `api/main.py` + smoke test endpointow
  - [x] Warning `nice(5) failed` przy `make api` to ograniczenie sandboxa (workaround w README) (2026-02-02)
- [x] API: read-only audit/metrics (pomocnicze) (branch: feat/api-audit-metrics) (2026-02-02)
  - [x] Endpointy: audit_event (lista + filtry), metrics_daily (lista + filtry)
  - [x] Endpointy: idea_candidate + idea_embedding (listy read-only)
- [x] Konsolidacja schematu DB pod `.ai/db-plan.md` (branch: fix/db-schema-core) (2026-02-02)
  - [x] Rozwiązać rozgałęzione heady Alembica (co najmniej 6e3cbd8f7f45, 1d7b9a2f6c3e, 1b9b3c2d9c1a, 9f3a2c7d8b1e) i przygotować plan merge-migracji
  - [x] Ustalić jeden kanoniczny schemat dokładnie wg `.ai/db-plan.md` (nazwy tabel, PK UUID, pola/typy/constrainty)
  - [x] Uporządkować migracje: usunąć/zmodyfikować te, które dublują elementy z `db-plan.md` (np. idea/ideas, animation/animations, render/renders, qc_decision/qc_decisions, audit_event/audit_logs, job/jobs)
  - [x] Ujednolicić pola idei wg `db-plan.md` i usunąć kolizje (`content_hash` vs `idea_hash`, indeksy `ix_ideas_content_hash`, itp.)
  - [x] Dopasować działające moduły z sekcji Done do docelowego schematu (Idea Gate, pipeline/jobs, embeddings, QC, render) oraz modele SQLAlchemy
  - [x] Priorytety dopasowania modułów: (1) pipeline/jobs + render + QC, (2) Idea Gate + embeddings, (3) audit log + publish/metrics
  - [x] Priorytet (1) pipeline/jobs + render + QC zrealizowany w MVP
  - [x] Priorytet (2) Idea Gate + embeddings zrealizowany w MVP
  - [x] Priorytet (3) audit log + publish/metrics zrealizowany w MVP
  - [x] Audit log + publish/metrics: minimalne flow (publish_record, metrics_pull_run, metrics_daily + audit_event)
  - [x] Idea Gate + embeddings dopasowane do nowego schematu (idea_batch/candidate/similarity)
  - [x] QC: dodać minimalny flow decyzji (checklist + qc_decision + audit_event + update animation status)
  - [x] Ustalić mapowanie statusów QC → animation.status/pipeline_stage (accepted/rejected/regenerate)
  - [x] Brak implementacji QC/publish/metrics w kodzie (wymaga integracji z tabelami)
  - [x] Zweryfikować wymagania RLS/roles/extensions (pgcrypto/citext/pg_trgm) kontra środowiska i spisać decyzję (włączone/wyłączone) w docs
  - [x] Zdecydować gdzie utrwalamy embeddingi dla podobieństwa idei przy nowym schemacie (obecnie liczone on-the-fly)
  - [x] Zapisywać embeddingi do nowej tabeli `idea_embedding` w Idea Gate (do wdrożenia w kodzie)
  - [x] Zaktualizować dokumentację (README/.ai/prd/.ai/db-plan) do stanu zgodnego z finalnym schematem
  - [x] `make db-migrate` → migracje przechodzą bez błędów; brak nowych warningów
  - [x] `make verify` → wszystkie testy/validations pass; brak regresji
  - [x] Usunąć warning DeprecationWarning (datetime.utcnow) w flow Idea Gate/idea-generate
  - [x] Wyjaśnić/naprawić mismatch golden testów renderera (happy.json) lub zregenerować goldeny
  - [x] Zdiagnozować warning renderera: `fsm.when.type=metric` nieobsługiwany (czy to oczekiwane w MVP)
  - [x] Zdiagnozować SIGPIPE w ffmpeg przy render job (czy powtarzalne)
  - [x] `make test` → testy przechodzą bez błędów
  - [x] `make enqueue` + `make worker` + `make job-status` → job kończy się `succeeded`
  - [x] `make idea-gate` lub `make idea-generate` → zapis pomysłów zgodny z `db-plan.md`
  - [x] `make worker` (logi) → brak błędów RLS/permissions; audit log zapisuje się w docelowej tabeli
- [x] Idea Gate + unikalnosc pomyslow (branch: feat/idea-gate) (2026-02-02)
  - [x] Propozycja 3–5 pomyslow i wybor operatora (opcjonalnie auto) (2026-02-02)
  - [x] Hash DSL + embedding pomyslu do wykrywania podobienstw (2026-02-02)
  - [x] Prog podobienstwa + oznaczanie zbyt podobnych pomyslow (2026-02-02)
  - [x] Uruchomic `make db-migrate` lokalnie (kolumny Idea Gate) (2026-02-02)
  - [x] Zastapic hash-embedding przez modul Embeddings (dependency) (2026-02-02)
  - [x] Wpiac Idea Gate jako etap opcjonalny w pipeline (przed generacja DSL) (2026-02-02)
  - [x] Rozszerzyc opisy propozycji (co uzytkownik ma zobaczyc w animacji) (2026-02-02)
  - [x] Dodac "preview" oczekiwanego efektu (np. kluczowe reguly/skrot DSL) (2026-02-02)
  - [x] Zapisac rozszerzone pola (what_to_expect/preview) w DB (Idea) lub metadanych (2026-02-02)
  - [x] Uruchomic `make db-migrate` lokalnie (idea details fields) (2026-02-02)
  - [x] Zrodlo pomyslow: generator + fallback do pliku (integracja) (2026-02-02)
- [x] Idea Gate – poprawki wyboru (auto + warning) (2026-02-02)
  - [x] Usunac warning datetime.utcnow + poprawic auto-selekcje przy `too_similar` (2026-02-02)
- [x] Generator pomysłów (moduł) (branch: feat/idea-generator) (2026-02-02)
  - [x] Generowanie pomysłów (provider template + prompt) (2026-02-02)
  - [x] Zapisywanie propozycji do DB (Idea) z metadanymi generacji (2026-02-02)
  - [x] Fallback do `.ai/ideas.md` gdy provider niedostępny (2026-02-02)
  - [x] Walidacja jakości i deduplikacja wejścia (hash/embedding) (2026-02-02)
- [x] Embedding Service: smoke test sklearn hashing (branch: test/embedding-service) (2026-02-02)
  - [x] Dodac smoke test do `scripts/verify-env.sh` (2026-02-02)
  - [x] Zweryfikowac lokalne dzialanie HashingVectorizer w testowym srodowisku (2026-02-02)
  - [x] Uzgodnic pin wersji scikit-learn (1.8.0) w `versions.env` (2026-02-02)
- [x] Embedding Service: zmiana providera na sklearn hashing (branch: fix/embedding-provider) (2026-02-02)
  - [x] Podmienic domyslny provider i zaleznosci na scikit-learn (2026-02-02)
  - [x] Zaktualizowac verify-env (smoke test sklearn) (2026-02-02)
  - [x] Zaktualizowac PRD/tech-stack i versions.env (2026-02-02)
- [x] Embedding Service (moduł) (branch: feat/embedding-service) (2026-02-02)
  - [x] Adapter fastembed (lokalne embeddings, CPU) (2026-02-02)
  - [x] Cache + retry + rate limit (2026-02-02)
  - [x] Wersjonowanie embeddingu w DB (model + wersja) (2026-02-02)
  - [x] Fallback do hash-embeddingu w trybie offline (2026-02-02)
- [x] Mapa zależności modułów (branch: docs/module-deps) (2026-02-02)
  - [x] Wybrać format (Mermaid/UML/ASCII) i zapisać w repo (2026-02-02)
  - [x] Zarysować zależności między modułami (pipeline, Idea Gate, generator, embeddings, UI) (2026-02-02)
- [x] Sync TODO po merge (moduły/zależności) (branch: chore/todo-sync) (2026-02-02)
  - [x] Sprawdzić, czy nowe moduły są wpisane w `TODO.md` na `main` (2026-02-02)
- [x] Konfiguracja i dokumentacja pipeline (branch: docs/pipeline-ops) (2026-02-02)
  - [x] Opisać minimalny flow uruchomienia (worker/enqueue/job-status) (2026-02-02)
  - [x] Opisać zmienne `.env` (REDIS_URL, RQ_*_TIMEOUT, FFMPEG_TIMEOUT_S) (2026-02-02)
  - [x] Dodać notkę o typowych problemach (ffmpeg hang + rozwiązanie) (2026-02-02)
- [x] Cleanup i obserwowalność pipeline (branch: chore/pipeline-maintenance) (2026-02-02)
  - [x] Wyczyścić/oznaczyć stare joby „running” w DB (po timeoutach) (2026-02-02)
  - [x] Dodać prosty status komendy: summary (queued/running/failed/succeeded) (2026-02-02)
  - [x] Dodać instrukcję cleanupu FailedJobRegistry w README/Makefile (2026-02-02)
- [x] Minimalny worker pipeline (branch: feat/pipeline-mvp) (2026-02-02)
  - [x] Zdefiniować minimalny kontrakt jobów i statusów (queued/running/succeeded/failed) (2026-02-02)
  - [x] Dodać modele DB: Job/Stage lub wykorzystać istniejące (AuditLog) do statusów (2026-02-02)
  - [x] Wpiąć RQ + Redis i dodać worker CLI (start/stop) (2026-02-02)
  - [x] Zaimplementować minimalny flow: generacja DSL -> render CLI (2026-02-02)
  - [x] Zastąpić stub generacji DSL (kopiowanie template) prawdziwą generacją (2026-02-02)
  - [x] Zapis statusów i artefaktów (DSL path, video path, metadata path) (2026-02-02)
  - [x] Retry podstawowy dla failed (manualny rerun) (2026-02-02)
  - [x] Dodać make targets: worker, enqueue, status (2026-02-02)
  - [x] Uruchomić `make db-migrate` lokalnie (tabela jobs) (2026-02-02)
  - [x] Zainstalować zależności pipeline (`make deps-py-uv`) i potwierdzić `rq`/`redis` (2026-02-02)
  - [x] Podnieść timeout renderu i dodać hooki on_failure/on_success dla RQ (2026-02-02)
  - [x] Zweryfikować, czy render job kończy się `succeeded` po zmianie timeoutu (2026-02-02)
  - [x] Zdiagnozować długotrwały render (ffmpeg/renderer) i ustalić docelowy timeout (2026-02-02)
  - [x] Sprawdzić ręczny render CLI na DSL z pipeline (czy ffmpeg kończy) (2026-02-02)
  - [x] Użyć absolutnych ścieżek + `-nostdin` w ffmpeg (unikać zależności od CWD) (2026-02-02)
  - [x] Dodać timeout i weryfikację outputu ffmpeg w rendererze (2026-02-02)
- [x] Baza danych + migracje (branch: feat/db-schema) (2026-02-02)
  - [x] Szkielet DB (Postgres + Alembic) (2026-02-01)
  - [x] Podstawowy model danych: animacja, render, QC, audit (2026-02-01)
  - [x] Dostosować PGDATA/volume dla Postgresa 18 (2026-02-02)
  - [x] Ustalić działający obraz MinIO (minio/minio vs alpine/minio) (2026-02-02)
  - [x] Migracje startowe (2026-02-02)
  - [x] Naprawić nagłówek migracji Alembic (nierenderowane placeholdery) (2026-02-02)
  - [x] Zweryfikować konfigurację template Alembic (nagłówki w nowych migracjach) (2026-02-02)
  - [x] Rozważyć server_default dla timestamps (created_at/updated_at) na poziomie DB (2026-02-02)
  - [x] Rozwiązać panic uv przy `make db-migrate` na macOS (system-configuration / Tokio executor) (2026-02-02)
  - [x] Uruchomić `make db-migrate` lokalnie (poza sandboxem) i potwierdzić sukces (2026-02-02)
- [x] Renderer: implementacja reguł (branch: feat/renderer-rules) (2026-02-01)
  - [x] Reguły: move / orbit / attract / repel (2026-02-01)
  - [x] Reguły: split / merge / decay (2026-02-01)
  - [x] Reguły: memory + ślady (2026-02-01)
  - [x] FSM w rendererze (2026-02-01)
  - [x] Zgodność kolejności ewaluacji z DSL (forces/interactions/constraints) (2026-02-01)
  - [x] Obsługa selectorów `tag:`/`all` i wyboru „najbliższego” w center/target (2026-02-01)
  - [x] Emitery: spawny w czasie zgodne z DSL v1.1 (2026-02-01)
  - [x] Emitery: obsłużyć `entities.size` z min/max/distribution (2026-02-01)
  - [x] Constraints/bounds: clamp/bounce/wrap zgodnie z DSL v1.1 (2026-02-01)
  - [x] Bounds: uwzględnić rozmiar obiektu (radius) w clamp/bounce (2026-02-01)
  - [x] Forces: gravity/noise zgodnie z DSL v1.1 (2026-02-01)
  - [x] Forces: uwzględnić `noise.scale` i `noise.seed` (2026-02-01)
  - [x] Doprecyzować obsługę `entities.size.value` (usunąć lub dodać do DSL) (2026-02-01)
  - [x] Forces: ustalić zachowanie `noise.seed` w czasie (statyczny vs zmienny) (2026-02-01)
  - [x] Zgodność reguł z DSL v1.1 (po rozszerzeniu) (2026-02-01)
  - [x] Interactions: implementacja `systems.interactions` (pairs + when) (2026-02-01)
  - [x] FSM: obsługa `metric` (przynajmniej population) (2026-02-01)
  - [x] Termination: obsługa `condition.type = metric` (przynajmniej population) (2026-02-01)
  - [x] Interactions: obsługa `merge`/`split` w `systems.interactions` (2026-02-01)
  - [x] Metryki: `coverage` / `entropy` / `stability` w FSM i termination (2026-02-01)
  - [x] Interactions: stabilne RNG dla `when.probability` (2026-02-01)
  - [x] Metryki: doprecyzować semantykę (coverage/stability/entropy) i dostosować implementację (2026-02-01)
  - [x] Interactions: split/merge zgodne z parametrami DSL (np. angle_threshold_deg) (2026-02-01)
- [x] DSL v1.1 rozszerzenia (branch: feat/dsl-v1-1) (2026-02-01)
- [x] Utworzenie TODO.md (branch: chore/todo) (2026-01-30)
  - [x] Zdefiniować strukturę zadań i zasady utrzymania TODO (2026-01-30)
- [x] Dev environment bootstrap (branch: chore/dev-setup) (2026-01-31)
  - [x] Zweryfikować i uzupełnić środowisko dev na macOS (Brewfile + versions.env)
  - [x] Przygotować skrypt bootstrapu macOS (scripts/setup-macos.sh) i wpisać do Makefile (2026-01-30)
  - [x] Wymusić użycie /opt/homebrew w bootstrapie i zweryfikować ścieżkę brew (2026-01-30)
  - [x] Instalować tylko brakujące brew/cask (pomijać istniejący Docker.app) (2026-01-30)
  - [x] Trwale pominąć instalację Docker cask w bootstrapie (2026-01-30)
  - [x] Przenieść wersje Python/Node do mise i dodać .mise.toml (2026-01-31)
  - [x] Zaufać konfiguracji mise (mise trust) (2026-01-31)
  - [x] Naprawić uprawnienia Homebrew i cache (np. /opt/homebrew/Cellar, /opt/homebrew/var/homebrew/locks, ~/Library/Caches/Homebrew) (2026-01-31)
  - [x] Sprawdzić ACL/flags blokujące zapis (np. /opt/homebrew/var/homebrew/locks, ~/Library/Caches/Homebrew) (2026-01-31)
  - [x] Ustawić Node 24 jako aktywny przez mise (2026-01-31)
  - [x] Ustalić, że `make verify` traktuje skia-python i usługi z compose jako opcjonalne (2026-01-31)
  - [x] Usunąć tap `homebrew/bundle` z Brewfile (tap zdeprecjonowany) (2026-01-30)
  - [x] Uruchomić bootstrap lokalnie i potwierdzić działanie (make setup-macos, make verify) (2026-01-31)
  - [x] Spisać minimalne kroki uruchomienia lokalnego (README: 5-min quickstart) (2026-01-31)
- [x] DSL v1 + walidacja (branch: feat/dsl-v1) (2026-02-01)
  - [x] Opisać DSL v1: struktura pliku, pola wymagane, opcjonalne, wersjonowanie (2026-01-31)
  - [x] Zdefiniować minimalny kontrakt FSM (stany, przejścia, parametry, wejścia/wyjścia) (2026-01-31)
  - [x] Przygotować 2 przykładowe pliki DSL v1 (happy path + edge case) (2026-01-31)
  - [x] Wybrać format wejścia (JSON albo YAML) i uzasadnić w krótkiej notce (2026-01-31)
  - [x] Zaimplementować schemat DSL (pydantic/jsonschema) + walidator wejścia (2026-01-31)
  - [x] Dodać testy walidacji DSL (min. valid/invalid cases) (2026-01-31)
  - [x] Dodać zależności Python (pyproject + lock) dla DSL/testów (pydantic, pyyaml, pytest) (2026-02-01)
  - [x] Usunąć warningi Pydantic v2 (Config -> ConfigDict) (2026-02-01)
- [x] Minimalny renderer MVP (branch: feat/renderer-mvp) (2026-02-01)
  - [x] Renderer Python + Cairo z deterministycznym seedingiem (2026-02-01)
  - [x] Metadane renderu: seed, dsl_version, design_system_version, parametry symulacji (2026-02-01)
  - [x] Ustalić spójną wersję FFmpeg w PATH (obecnie używany 7.1.1 vs pinned 8.0.1) (2026-02-01)
  - [x] Ostrzeganie o nieobsługiwanych regułach/FSM w rendererze (2026-02-01)
- [x] CLI do renderu (branch: feat/render-cli) (2026-02-01)
  - [x] Wejście: DSL + seed, wyjście: wideo + metadane (2026-02-01)
  - [x] Walidacja wejścia i czytelne błędy (2026-02-01)
- [x] Deterministyczność renderu (branch: test/renderer-golden) (2026-02-01)
  - [x] Golden tests (min. 2 przypadki) (2026-02-01)
  - [x] Tolerancje porównań i dokumentacja (2026-02-01)

## Zasady
- Jeden właściciel taska i jeden cel; task ma kończyć się działającym artefaktem lub testem
- Przenoś zadania między sekcjami tylko przy zmianie statusu (Now -> Done, Next -> Now)
- Dopisuj datę przy ukończonych zadaniach w sekcji Done, np. "(2026-01-30)"
- Zadania główne odpowiadają branchom (jedno zadanie = jeden branch), podzadania realizujemy w ramach tego brancha
- Preferowane prefiksy branchy: `feat/`, `chore/`, `test/`, `docs/`, `fix/`
- Zadanie główne powinno być zamykalne w 1–3 dni robocze; jeśli rośnie, podziel je na dwa branche
- TODO utrzymujemy jako 2 poziomy: tylko zadania główne + podzadania (bez kolejnych poziomów)
- Liczba podzadań jest elastyczna (1–7); przy 1 podzadaniu upewnij się, że branch nadal ma sens
- Przykład małego brancha: dokument/konwencja w jednym pliku (np. TODO, README, RFC-lite)

## Notatki / decyzje
- Docker Desktop instalujemy manualnie (bootstrap pomija cask docker).
- Python/Node instalujemy i pinujemy przez mise (`.mise.toml`).
- `make verify` traktuje skia-python i usługi z compose jako opcjonalne do czasu uruchomienia renderera i infra.
- Timestamps zostają na poziomie aplikacji (brak `server_default`) w MVP; ewentualne server-side defaults wymagają nowej migracji/triggerów.
